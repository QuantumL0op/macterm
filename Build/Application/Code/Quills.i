%define DOCSTRING
"The `Quills` module exposes the entire MacTelnet API to Python,
allowing you to directly access core functionality from scripts!"
%enddef

%module(docstring=DOCSTRING) quills

%include "exception.i"
%include "stl.i"

// include headers that should *not* be wrapped in Python, but are
// necessary for the implementation code in this file or in files
// that it includes while in SWIG mode
%{
#include <stdexcept>
#include <Console.h>
%}

// Apple’s "AssertMacros.h" contains errant #define macros that corrupt
// C++ code generated by SWIG - see rdar://4700324 for more on this.
// By undefining "check", check()-like methods are not corrupted.
%{
#ifdef check
#undef check
#endif
%}

// instantiate template types relied upon by Quills
%template(_float_list) std::vector< double >;
%template(_long_pair) std::pair< long, long >;
%template(_string_list) std::vector< std::string >;

// enable callbacks to be written in Python
#ifdef SWIGPYTHON
%typemap(in) PyObject* inPythonFunction
{
	if (false == PyCallable_Check($input))
	{
		PyErr_SetString(PyExc_TypeError, "Parameter is not a function");
		return NULL;
	}
	$1 = $input;
}
#endif

// Python exception-handling utility
#ifdef SWIGPYTHON
%{
/*!
Utility routine.  Given a Python string object, returns its
value or (if not defined) an appropriate description.

(4.0)
*/
static std::string
_Quills_PyStringDesc	(PyObject*		inString)
{
	std::string		result;
	
	
	if ((NULL != inString) && (NULL != PyString_AsString(inString)))
	{
		result = PyString_AsString(inString);
	}
	else
	{
		result = "<undefined>";
	}
	return result;
}// _Quills_PyStringDesc


/*!
Utility routine.  Given the Python objects representing the
value and traceback of an exception (both of which might be
NULL), returns an appropriate description of that exception.

(4.0)
*/
static std::string
_Quills_PyExceptionDesc		(PyObject*		inType,
							 PyObject*		inValue)
{
	std::string		result;
	
	
	// sort out the type
	if (NULL != inType)
	{
		// this is arbitrary; the more cases that are here, the more “helpful” the message;
		// should follow the inheritance tree documented by "pydoc exceptions"
		if (PyErr_GivenExceptionMatches(inType, PyExc_Exception))
		{
			if (PyErr_GivenExceptionMatches(inType, PyExc_ArithmeticError))
			{
				result = "<ArithmeticError derivative>";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_ImportError))
			{
				result = "ImportError";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_LookupError))
			{
				result = "<LookupError derivative>";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_RuntimeError))
			{
				result = "RuntimeError";
			}
			else if (PyErr_GivenExceptionMatches(inType, PyExc_SyntaxError))
			{
				result = "SyntaxError";
			}
			else
			{
				result = "<Exception derivative>";
			}
		}
		else
		{
			// ???
			result = "<Unknown type>";
		}
		result += ": ";
	}
	else
	{
		result += "<Undefined type>: ";
	}
	
	// sort out the value
	if (NULL != inValue)
	{
		result += _Quills_PyStringDesc(inValue);
	}
	else
	{
		result += "<no exception details found>";
	}
	
	return result;
}// _Quills_PyExceptionDesc


/*!
Utility routine.  Given a Python object returned by a call to
PyEval_CallObject(), checks to see if it is NULL and if so,
propagates the exception to the caller; otherwise, does nothing.
Certain exceptions will contain the specified description,
which should help the user to narrow down what the calling
routine is.

A “descriptive” C++ exception is thrown.  If the caller ends
up being Python, SWIG will re-translate this back to raise a
useful Python exception.  If the caller is C++, it can catch
the exception normally.

(4.0)
*/
static void
_Quills_PropagateExceptions		(void*					inResultObject,
								 std::string const&		inContext)
{
	if (NULL == inResultObject)
	{
		Console_WriteValueCString("Python exception was thrown", inContext.c_str());
		// an exception was thrown; translate it to an appropriate C++ exception
		// (which, actually, will AGAIN be translated back to Python by SWIG, if
		// in fact this was called via Python; otherwise, it can be trapped in C++)
		PyObject*		excType = NULL;
		PyObject*		excValue = NULL;
		PyObject*		excTrace = NULL;
		std::string		excMessage;
		PyErr_Fetch(&excType, &excValue, &excTrace);
		excMessage = "Python raised " + _Quills_PyExceptionDesc(excType, excValue);
		excMessage += "; ";
		excMessage += inContext;
		Py_XDECREF(excType), excType = NULL;
		Py_XDECREF(excValue), excValue = NULL;
		Py_XDECREF(excTrace), excTrace = NULL;
		if (false == excMessage.empty()) throw std::runtime_error(excMessage);
	}
}// _Quills_PropagateExceptions
%}
#endif

// enable callbacks that take a single string argument and return nothing
#ifdef SWIGPYTHON
%{
static void
CallPythonStringReturnVoid	(void*	inPythonFunctionObject,
							 char*	inoutString)
{
	PyObject*	pythonDef = NULL;
	PyObject*	arguments = NULL;	
	PyObject*	pythonResult = NULL;
	
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	arguments = Py_BuildValue("(s)", inoutString);
	assert(NULL != arguments);
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	Py_DECREF(arguments), arguments = NULL;
	_Quills_PropagateExceptions(pythonResult, "while C++ called a Python single-string-argument function that returns nothing");
	Py_XDECREF(pythonResult), pythonResult = NULL;
}
%}
#endif

// enable callbacks that take a single string argument and return a string
#ifdef SWIGPYTHON
%{
static std::string
CallPythonStringReturnString	(void*	inPythonFunctionObject,
								 char*	inoutString)
{
	PyObject*		pythonDef = NULL;
	PyObject*		arguments = NULL;	
	PyObject*		pythonResult = NULL;
	std::string		result;
	
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	arguments = Py_BuildValue("(s)", inoutString);
	assert(NULL != arguments);
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	Py_DECREF(arguments), arguments = NULL;
	_Quills_PropagateExceptions(pythonResult, "while C++ called a Python single-string-argument function that returns a string");
	if (NULL != pythonResult)
	{
		char const*		stringPtr = NULL;
		
		
		if (false == PyString_CheckExact(pythonResult))
		{
			PyErr_SetString(PyExc_TypeError, "Callback did not return a string");
			return result;
		}
		
		stringPtr = PyString_AsString(pythonResult);
		result = stringPtr;
	}
	Py_XDECREF(pythonResult), pythonResult = NULL;
	
	return result;
}
%}
#endif

// enable callbacks that take a string argument and a long-integer argument and return a long-integer pair
#ifdef SWIGPYTHON
%{
static std::pair<long, long>
CallPythonStringLongReturnLongPair	(void*	inPythonFunctionObject,
									 char*	inoutString,
									 long	inLong)
{
	PyObject*				pythonDef = NULL;
	PyObject*				arguments = NULL;	
	PyObject*				pythonResult = NULL;
	std::pair<long, long>	result;
	
	
	result.first = inLong;
	result.second = inLong;
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	arguments = Py_BuildValue("(s,l)", inoutString, inLong);
	assert(NULL != arguments);
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	Py_DECREF(arguments), arguments = NULL;
	_Quills_PropagateExceptions(pythonResult, "while C++ called a Python single-string-argument function that returns an integer pair");
	if (NULL != pythonResult)
	{
		PyObject*	item0 = nullptr;
		PyObject*	item1 = nullptr;
		
		
		if (false == PyTuple_CheckExact(pythonResult))
		{
			PyErr_SetString(PyExc_TypeError, "Callback did not return a tuple");
			return result;
		}
		
		item0 = PyTuple_GetItem(pythonResult, 0);
		if ((nullptr == item0) || (false == PyInt_CheckExact(item0)))
		{
			PyErr_SetString(PyExc_TypeError, "Callback did not return a tuple with an integer as a first item");
			return result;
		}
		result.first = PyInt_AsLong(item0);
		
		item1 = PyTuple_GetItem(pythonResult, 1);
		if ((nullptr == item1) || (false == PyInt_CheckExact(item1)))
		{
			PyErr_SetString(PyExc_TypeError, "Callback did not return a tuple with an integer as a second item");
			return result;
		}
		result.second = PyInt_AsLong(item1);
	}
	Py_XDECREF(pythonResult), pythonResult = NULL;
	
	return result;
}
%}
#endif

// enable callbacks that take no arguments and return nothing
#ifdef SWIGPYTHON
%{
static void
CallPythonVoidReturnVoid	(void*	inPythonFunctionObject)
{
	PyObject*	pythonDef = NULL;
	PyObject*	arguments = NULL;	
	PyObject*	pythonResult = NULL;
	
	
	pythonDef = reinterpret_cast< PyObject* >(inPythonFunctionObject);
	//arguments = Py_BuildValue("{items}");
	pythonResult = PyEval_CallObject(pythonDef, arguments); // call Python
	//Py_DECREF(arguments), arguments = NULL;
	_Quills_PropagateExceptions(pythonResult, "while C++ called a Python no-argument function that returns nothing");
	Py_XDECREF(pythonResult), pythonResult = NULL;
}
%}
#endif

// NOTE: Quills headers are the only MacTelnet headers designed to
// interact with SWIG.  They also define the entire Python API for
// MacTelnet in an organized way.  Try not to include other headers here.

// WARNING: Currently, PythonWrapper/GNUmakefile assumes the list of
// dependencies below.  If you add more includes, you should ensure the
// makefile will realize they are dependencies of the wrapper build.

%{
#include <QuillsBase.h>
#include <QuillsEvents.h>
#include <QuillsPrefs.h>
#include <QuillsSession.h>
#include <QuillsTerminal.h>
%}

// auto-generate standard first lines for each function docstring
// (basically, the function name, arguments and any return type);
// any additional %feature("docstring", ...) lines will ADD to
// the automatically generated lines caused by the statement below
%feature("autodoc", "0");

// declare C++ APIs that should be exposed to Python
%include <QuillsBase.h>
%include <QuillsEvents.h>
%include <QuillsPrefs.h>
%include <QuillsSession.h>
%include <QuillsTerminal.h>

// BELOW IS REQUIRED NEWLINE TO END FILE
